import Foundation
/*:
 # LBaC
 # Part X: Introducing "TINY"
 ## Part 1: Introduction
 
 If you don't remember, we were last trying to build Pascal/C compilers in previous chapters in a top-down fashion. However, we stopped during the process because I deemed it would be more fun to write a compiler for a language called `KISS` - specifically a subset called **TINY**.
 
 Here, we will take a slightly untraditional route. We will be *defining the language as we go*. Actually, we will be doing a top-down development for both the language and its compiler.
 
 > Along the way, we will make important decisions. If you don't agree, you can do whatever you'd like to do! It's your compiler after all!
 
 Now... we will start once again from a blank sheet of paper. Get excited ðŸ¤©ðŸ¤©ðŸ¤©
 
 ## About TINY
 TINY is a subset of KISS and because of this, there will be certain limitations to TINY.
 
 - Only one data type (16 bit integer)
 - No procedure calls
 - Single-character variable names
 
 But in a general sense, TINY will be similar to Pascal in some sense.
 */

let TAB : Character = "\t"
let LF = "\n"
let whiteChars: [Character] = [" ", TAB]

struct Buffer {
    var idx : Int
    var cur : Character?
    let input: String
}

extension Buffer {
    init() {
        idx = 0
        input = ""
        getChar()
    }
    
    mutating func getChar() {
        let i = input.index(input.startIndex, offsetBy: idx)
        
        if i == input.endIndex {
            cur = nil
        } else {
            cur = input[i]
            idx += 1
        }
    }
}

func error(msg: String) {
    print("Error: \(msg).")
}

func abort(msg: String) {
    error(msg: msg)
    exit(EXIT_FAILURE)
}

func expected(_ s: String) {
    abort(msg: "\(s) expected")
}

func emit(msg: String) {
    print("\(TAB) \(msg)", separator: "", terminator: "")
}

func emitLine(msg: String) {
    print("\(TAB) \(msg)")
}

func postLabel(_ label: String) {
    print("\(label):", terminator:"")
}

func isAlpha(_ c: Character?) -> Bool {
    if let c = c, "a"..."z" ~= c || "A"..."Z" ~= c {
        return true
    } else {
        return false
    }
}

func isDigit(_ c: Character?) -> Bool {
    if let c = c, "0"..."9" ~= c {
        return true
    } else {
        return false
    }
}

func isAlnum(_ c: Character?) -> Bool {
    return isAlpha(c) || isDigit(c)
}

func match(_ c: Character) {
    if LOOK.cur == c {
        LOOK.getChar()
    } else {
        expected("\(c)")
    }
}

func getName() -> Character {
    if !isAlpha(LOOK.cur) {
        expected("Name")
    }
    let upper = String(LOOK.cur!).uppercased().characters.first!
    LOOK.getChar()
    return upper
}

func getNum() -> Character {
    if !isDigit(LOOK.cur) {
        expected("Integer")
    }
    LOOK.getChar()
    return LOOK.cur!
}

/*:
 ### header
 Emits startup code required by the assembler
 */
func header() {
    emitLine(msg: "WARMST\tEQU $A01E")
}

/*:
 ### prolog & epilog
 Emits code for identifying the main program and returning it to the OS
 */
func prolog() {
    postLabel("MAIN")
}

func epilog() {
    emitLine(msg: "DC WARMST")
    emitLine(msg: "END MAIN")
}

/*:
 ### Main Blocks
 We will keep the `PROGRAM`, `.` syntax to denote beginning and end of main blocks.
 */
func prog() {
    match("p")
    header()
    prolog()
    match(".")
    epilog()
}

/*:
 ## So far...
 TINY will only accept on input
 ```
 PROGRAM .
 ```
 or `p.` in shorthand.
 
 > Short and useless as it is, the code generated by our compiler will run and do what you'd expect it to do; nothing.
 
 > Compiling, linking and executing null programs can actually reveal many interesting things about the compiler. *VAX C generated 50K of code for a null program ðŸ˜³*
 
 Since we don't have any run-time libraries, our's is tiny.... **2 bytes** ðŸŽ‰ðŸŽ‰ðŸŽ‰
 */
func initialize() -> Buffer {
    var LOOK = Buffer(idx: 0, cur: nil, input: "p.")
    LOOK.getChar()
    return LOOK
}

var LOOK = initialize()
prog()
if LOOK.cur != nil {
    abort(msg: "Unexpected data after `.`")
}
